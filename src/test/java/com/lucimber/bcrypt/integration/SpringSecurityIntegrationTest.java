/*
 * SPDX-FileCopyrightText: 2025 Lucimber UG
 * SPDX-License-Identifier: Apache-2.0
 */
package com.lucimber.bcrypt.integration;

import static org.junit.jupiter.api.Assertions.*;

import com.lucimber.bcrypt.*;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

/**
 * Integration tests comparing our BCrypt implementation with Spring Security's implementation.
 * These tests ensure our implementation is compatible with Spring Security's BCrypt.
 */
class SpringSecurityIntegrationTest {

    private final BCryptService service = BCryptService.getInstance();
    private final BCryptPasswordEncoder springEncoder = new BCryptPasswordEncoder();

    @Test
    @DisplayName("Should verify Spring Security generated hash")
    void shouldVerifySpringSecurityGeneratedHash() {
        String rawPassword = "myTestPassword123";

        // Generate hash with Spring Security
        String springHash = springEncoder.encode(rawPassword);

        // Verify with our implementation
        Password password = new Password(rawPassword);
        Hash hash = new Hash(springHash);

        assertTrue(
                service.verify(password, hash), "Should verify hash generated by Spring Security");
    }

    @Test
    @DisplayName("Spring Security should verify our generated hash")
    void springSecurityShouldVerifyOurGeneratedHash() {
        String rawPassword = "anotherTestPassword";

        // Generate hash with our implementation
        Password password = new Password(rawPassword);
        Hash ourHash = service.hash(password);

        // Verify with Spring Security
        assertTrue(
                springEncoder.matches(rawPassword, ourHash.getValue()),
                "Spring Security should verify hash generated by our implementation");
    }

    @Test
    @DisplayName("Should handle various passwords compatibly with Spring Security")
    void shouldHandleVariousPasswordsCompatibly() {
        String[] passwords = {
            "simple",
            "WithNumbers123",
            "With!@#$%^&*()Symbols",
            "VeryLongPasswordThatIsStillWithinThe72ByteLimit1234567890",
            "Unicode密码пароль",
            "Tab\tNewline\nCarriageReturn\r"
        };

        for (String rawPassword : passwords) {
            // Skip if exceeds limit
            if (rawPassword.getBytes().length > 72) {
                continue;
            }

            // Generate with Spring Security
            String springHash = springEncoder.encode(rawPassword);

            // Verify with our implementation
            Password password = new Password(rawPassword);
            Hash hash = new Hash(springHash);
            assertTrue(
                    service.verify(password, hash),
                    "Should verify Spring hash for password: " + rawPassword);

            // Generate with our implementation
            Hash ourHash = service.hash(password);

            // Verify with Spring Security
            assertTrue(
                    springEncoder.matches(rawPassword, ourHash.getValue()),
                    "Spring should verify our hash for password: " + rawPassword);
        }
    }

    @Test
    @DisplayName("Should handle different cost factors like Spring Security")
    void shouldHandleDifferentCostFactorsLikeSpring() {
        String rawPassword = "testCostFactors";

        // Test various cost factors
        int[] costs = {4, 10, 12, 15};

        for (int cost : costs) {
            // Spring Security with specific cost
            BCryptPasswordEncoder springWithCost = new BCryptPasswordEncoder(cost);
            String springHash = springWithCost.encode(rawPassword);

            // Verify with our implementation
            Password password = new Password(rawPassword);
            Hash hash = new Hash(springHash);

            assertTrue(
                    service.verify(password, hash),
                    "Should verify Spring hash with cost factor " + cost);

            // Verify the cost factor is correct
            assertEquals(cost, hash.getCostFactor().getValue(), "Cost factor should be " + cost);

            // Generate with our implementation
            CostFactor costFactor = new CostFactor(cost);
            Hash ourHash = service.hash(password, BCryptVersion.VERSION_2A, costFactor);

            // Spring should verify our hash
            assertTrue(
                    springWithCost.matches(rawPassword, ourHash.getValue()),
                    "Spring should verify our hash with cost factor " + cost);
        }
    }

    @Test
    @DisplayName("Should handle 2a version like Spring Security")
    void shouldHandle2aVersionLikeSpring() {
        String rawPassword = "test2aVersion";

        // Spring uses 2a by default
        BCryptPasswordEncoder spring2a = new BCryptPasswordEncoder();
        String springHash = spring2a.encode(rawPassword);

        // Verify it's 2a
        assertTrue(springHash.startsWith("$2a$"), "Spring should generate 2a hashes");

        // Our implementation should verify it
        Password password = new Password(rawPassword);
        Hash hash = new Hash(springHash);

        assertTrue(service.verify(password, hash), "Should verify Spring's 2a hash");

        // Generate 2a with our implementation
        Hash ourHash = service.hash(password, BCryptVersion.VERSION_2A);

        // Spring should verify our 2a hash
        assertTrue(
                spring2a.matches(rawPassword, ourHash.getValue()),
                "Spring should verify our 2a hash");
    }

    @Test
    @DisplayName("Should handle 2b version compatibility")
    void shouldHandle2bVersionCompatibility() {
        String rawPassword = "test2bVersion";

        // Generate 2b with our implementation
        Password password = new Password(rawPassword);
        Hash our2bHash = service.hash(password, BCryptVersion.VERSION_2B);

        // Spring Security should still be able to verify 2b hashes
        // (Spring primarily generates 2a but can verify 2b)
        BCryptPasswordEncoder springEncoder = new BCryptPasswordEncoder();

        // Note: Spring Security's BCrypt can verify 2b hashes even though it generates 2a
        assertTrue(
                springEncoder.matches(rawPassword, our2bHash.getValue()),
                "Spring should be able to verify our 2b hash");
    }

    @Test
    @DisplayName("Should reject wrong passwords like Spring Security")
    void shouldRejectWrongPasswordsLikeSpring() {
        String correctPassword = "correctPassword123";
        String wrongPassword = "wrongPassword123";

        // Generate with Spring
        String springHash = springEncoder.encode(correctPassword);

        // Both implementations should reject wrong password
        Password wrongPwd = new Password(wrongPassword);
        Hash hash = new Hash(springHash);

        assertFalse(
                service.verify(wrongPwd, hash), "Our implementation should reject wrong password");

        assertFalse(
                springEncoder.matches(wrongPassword, springHash),
                "Spring should reject wrong password");

        // Generate with our implementation
        Password correctPwd = new Password(correctPassword);
        Hash ourHash = service.hash(correctPwd);

        assertFalse(
                springEncoder.matches(wrongPassword, ourHash.getValue()),
                "Spring should reject wrong password for our hash");
    }

    @Test
    @DisplayName("Should handle password truncation at 72 bytes like Spring")
    void shouldHandlePasswordTruncationLikeSpring() {
        // Passwords longer than 72 bytes
        String longPassword = "a".repeat(100);
        String truncatedTo72 = "a".repeat(72);

        // Spring Security 6.5.3+ now throws exception for passwords > 72 bytes
        assertThrows(
                IllegalArgumentException.class,
                () -> {
                    springEncoder.encode(longPassword);
                },
                "Spring Security 6.5.3+ throws exception for passwords > 72 bytes");

        // Spring Security should work with exactly 72 bytes
        String springHash72 = springEncoder.encode(truncatedTo72);
        assertTrue(
                springEncoder.matches(truncatedTo72, springHash72),
                "Spring should handle 72-byte passwords");

        // Our implementation truncates internally and should verify
        Password truncatedPwd = new Password(truncatedTo72);
        Hash hash = new Hash(springHash72);

        assertTrue(
                service.verify(truncatedPwd, hash),
                "Our implementation should verify Spring's 72-byte hash");

        // Generate with our implementation (which truncates internally)
        Password longPwd = new Password(longPassword);
        Hash ourHash = service.hash(longPwd);

        // Spring should verify with truncated password
        assertTrue(
                springEncoder.matches(truncatedTo72, ourHash.getValue()),
                "Spring should verify our truncated hash with 72-byte password");
    }

    @Test
    @DisplayName("Should handle empty-like passwords compatibly")
    void shouldHandleEmptyLikePasswordsCompatibly() {
        // Note: Both implementations should reject truly empty passwords,
        // but should handle single character and whitespace passwords
        String[] edgeCasePasswords = {
            " ", // Single space
            "a", // Single character
            "\t", // Tab
            "  ", // Multiple spaces
        };

        for (String rawPassword : edgeCasePasswords) {
            // Generate with Spring
            String springHash = springEncoder.encode(rawPassword);

            // Verify with our implementation
            Password password = new Password(rawPassword);
            Hash hash = new Hash(springHash);

            assertTrue(
                    service.verify(password, hash),
                    "Should verify Spring hash for edge case: '" + rawPassword + "'");

            // Generate with our implementation
            Hash ourHash = service.hash(password);

            // Verify with Spring
            assertTrue(
                    springEncoder.matches(rawPassword, ourHash.getValue()),
                    "Spring should verify our hash for edge case: '" + rawPassword + "'");
        }
    }

    @Test
    @DisplayName("Cross-validation with known test vectors")
    void crossValidationWithKnownTestVectors() {
        // Valid BCrypt test vectors from the official test suite
        // These are real, working BCrypt hashes
        String[][] testVectors = {
            {"abc123xyz", "$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW"},
            {"a", "$2a$10$k87L/MF28Q673VKh8/cPi.SUl7MU/rWuSiIDDFayrKk/1tBsSQu4u"},
            {"abc", "$2a$10$WvvTPHKwdBJ3uk0Z37EMR.hLA2W6N9AEBhEgrAOljy2Ae5MtaSIUi"},
            {
                "abcdefghijklmnopqrstuvwxyz",
                "$2a$10$fVH8e28OQRj9tqiDXs1e1uxpsjN0c7II7YPKXua2NAKYvM6iQk7dq"
            },
            {
                "~!@#$%^&*()      ~!@#$%^&*()PNBFRD",
                "$2a$10$LgfYWkbzEvQ4JakH7rOvHe0y8pHKF9OaFgwUZ2q7W2FFZmZzJYlfS"
            }
        };

        for (String[] vector : testVectors) {
            String rawPassword = vector[0];
            String knownHash = vector[1];

            // Both implementations should verify known hash
            Password password = new Password(rawPassword);
            Hash hash = new Hash(knownHash);

            assertTrue(
                    service.verify(password, hash),
                    "Our implementation should verify known hash for: " + rawPassword);

            assertTrue(
                    springEncoder.matches(rawPassword, knownHash),
                    "Spring should verify known hash for: " + rawPassword);
        }
    }
}
