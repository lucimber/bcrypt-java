package com.lucimber.crypto.bcrypt.integration;

import static org.junit.jupiter.api.Assertions.*;

import java.security.SecureRandom;

import com.lucimber.crypto.bcrypt.*;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

/**
 * Integration tests comparing our BCrypt implementation with Bouncy Castle's implementation. These
 * tests ensure our implementation is compatible with a widely-used cryptographic library.
 */
class BouncyCastleIntegrationTest {

    private final BCryptService service = BCryptService.getInstance();
    private final SecureRandom random = new SecureRandom();

    @Test
    @DisplayName("Should generate hash compatible with Bouncy Castle")
    void shouldGenerateHashCompatibleWithBouncyCastle() {
        String passwordString = "testPassword123";

        // Generate with our implementation using 2a (which BC uses)
        Password password = new Password(passwordString);
        Hash ourHash = service.hash(password, BCryptVersion.VERSION_2A);

        // Verify with Bouncy Castle using helper
        boolean bcVerifies =
                BouncyCastleHelper.verifyWithBouncyCastle(passwordString, ourHash.getValue());
        assertTrue(bcVerifies, "Bouncy Castle should verify our hash");

        // Generate with Bouncy Castle using same parameters
        String bcHash = BouncyCastleHelper.hashLikeExisting(passwordString, ourHash.getValue());

        // Both should produce the same hash
        assertEquals(ourHash.getValue(), bcHash, "Our hash and BC hash should match");
    }

    @Test
    @DisplayName("Should verify Bouncy Castle generated hash")
    void shouldVerifyBouncyCastleGeneratedHash() {
        String passwordString = "anotherTestPassword";

        // Generate a salt
        byte[] salt = new byte[16];
        random.nextBytes(salt);

        // Generate hash with Bouncy Castle using helper
        int cost = 12;
        String bcHash = BouncyCastleHelper.hashWithBouncyCastle(passwordString, salt, cost);

        // Verify with our implementation
        Password password = new Password(passwordString);
        Hash hash = new Hash(bcHash);

        assertTrue(service.verify(password, hash), "Should verify hash generated by Bouncy Castle");

        // Also verify that BC can verify its own hash
        assertTrue(
                BouncyCastleHelper.verifyWithBouncyCastle(passwordString, bcHash),
                "BC should verify its own hash");
    }

    @Test
    @DisplayName("Should handle various cost factors like Bouncy Castle")
    void shouldHandleVariousCostFactorsLikeBouncyCastle() {
        String passwordString = "testWithDifferentCosts";
        byte[] salt = new byte[16];
        random.nextBytes(salt);

        int[] costs = {4, 10, 12, 15};

        for (int cost : costs) {
            // Generate with BC using helper
            String bcHash = BouncyCastleHelper.hashWithBouncyCastle(passwordString, salt, cost);

            // Verify with our implementation
            Password password = new Password(passwordString);
            Hash hash = new Hash(bcHash);

            assertTrue(service.verify(password, hash), "Should verify BC hash with cost " + cost);

            // Generate with our implementation
            CostFactor costFactor = new CostFactor(cost);
            Salt ourSalt = new Salt(salt);
            Hash ourHash = service.hash(password, BCryptVersion.VERSION_2A, costFactor, ourSalt);

            // Both should produce same hash
            assertEquals(bcHash, ourHash.getValue(), "Hashes should match for cost " + cost);
        }
    }

    @Test
    @DisplayName("Should produce different hashes for different salts like Bouncy Castle")
    void shouldProduceDifferentHashesForDifferentSaltsLikeBouncyCastle() {
        String passwordString = "samePassword";

        // Generate two different salts
        byte[] salt1 = new byte[16];
        byte[] salt2 = new byte[16];
        random.nextBytes(salt1);
        random.nextBytes(salt2);

        // Generate with BC
        String bcHash1 = BouncyCastleHelper.hashWithBouncyCastle(passwordString, salt1, 10);
        String bcHash2 = BouncyCastleHelper.hashWithBouncyCastle(passwordString, salt2, 10);

        // BC should produce different hashes
        assertNotEquals(bcHash1, bcHash2, "BC should produce different hashes for different salts");

        // Generate with our implementation
        Password password = new Password(passwordString);
        Salt ourSalt1 = new Salt(salt1);
        Salt ourSalt2 = new Salt(salt2);
        CostFactor cost = new CostFactor(10);

        Hash ourHash1 = service.hash(password, BCryptVersion.VERSION_2A, cost, ourSalt1);
        Hash ourHash2 = service.hash(password, BCryptVersion.VERSION_2A, cost, ourSalt2);

        // We should also produce different hashes
        assertNotEquals(
                ourHash1.getValue(),
                ourHash2.getValue(),
                "Our implementation should produce different hashes for different salts");

        // Our hashes should match BC hashes
        assertEquals(bcHash1, ourHash1.getValue(), "First hash should match BC");
        assertEquals(bcHash2, ourHash2.getValue(), "Second hash should match BC");
    }

    @Test
    @DisplayName("Should handle UTF-8 passwords like Bouncy Castle")
    void shouldHandleUtf8PasswordsLikeBouncyCastle() {
        String[] passwords = {"简体中文", "Русский", "العربية", "emojis😀🎉", "mixed混合мешаный"};

        for (String passwordString : passwords) {
            // Skip if exceeds limit
            if (passwordString.getBytes().length > 72) {
                continue;
            }

            byte[] salt = new byte[16];
            random.nextBytes(salt);

            // Generate with BC using helper
            String bcHash = BouncyCastleHelper.hashWithBouncyCastle(passwordString, salt, 10);

            // Our implementation should verify
            Password password = new Password(passwordString);
            Hash hash = new Hash(bcHash);

            assertTrue(
                    service.verify(password, hash),
                    "Should handle UTF-8 password: " + passwordString);

            // Generate with our implementation
            Salt ourSalt = new Salt(salt);
            Hash ourHash =
                    service.hash(password, BCryptVersion.VERSION_2A, new CostFactor(10), ourSalt);

            // Should produce same hash
            assertEquals(
                    bcHash,
                    ourHash.getValue(),
                    "Hashes should match for UTF-8 password: " + passwordString);
        }
    }

    @Test
    @DisplayName("Should handle password truncation at 72 bytes like Bouncy Castle")
    void shouldHandlePasswordTruncationLikeBouncyCastle() {
        // Password longer than 72 bytes
        String longPassword = "a".repeat(100);
        String truncatedPassword = "a".repeat(72);

        byte[] salt = new byte[16];
        random.nextBytes(salt);

        // Generate with BC using helper
        String bcHashLong = BouncyCastleHelper.hashWithBouncyCastle(longPassword, salt, 10);
        String bcHashTruncated =
                BouncyCastleHelper.hashWithBouncyCastle(truncatedPassword, salt, 10);

        // BC should produce same hash for both (truncates at 72)
        assertEquals(bcHashTruncated, bcHashLong, "BC should truncate at 72 bytes");

        // Our implementation should also truncate
        Password longPwd = new Password(longPassword);
        Password truncPwd = new Password(truncatedPassword);
        Salt ourSalt = new Salt(salt);

        Hash hashLong =
                service.hash(longPwd, BCryptVersion.VERSION_2A, new CostFactor(10), ourSalt);
        Hash hashTrunc =
                service.hash(truncPwd, BCryptVersion.VERSION_2A, new CostFactor(10), ourSalt);

        assertEquals(
                hashTrunc.getValue(),
                hashLong.getValue(),
                "Our implementation should truncate at 72 bytes");

        // All should produce the same hash
        assertEquals(
                bcHashLong,
                hashLong.getValue(),
                "Our hash should match BC hash for truncated password");
    }
}
